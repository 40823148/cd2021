var tipuesearch = {"pages": [{'title': 'About', 'text': '\n \n 20歲 是大學生 \n 網站維護什麼的有在做 \n \n 本次課程以分組設計產品為主 \n 個人網站已更新個人活動及分組心得 \n 個人倉儲 \n YouTube \n \n \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'stage1', 'text': '兩人一組 以短時間內設計產品 \n 組別網站 \n 產品題目 :四驅車 \n \n 組員 \n 40823127 陳佑杰 \n 組員倉儲 \n 40823148 韋誠昌 \n 組員倉儲 \n \n', 'tags': '', 'url': 'stage1.html'}, {'title': 'stage1工作內容', 'text': '負責車體尺寸設計 繪圖 以及 CoppleliaSim 模擬 \n \n 產品尺寸設計 \n 先以2D軟體設計尺寸 再以3D軟體建模 \n 2d產品設計圖▼ \n \n 3d軟體實體圖▼ \n \n \n \n CoppleliaSim模擬 \n 3D軟體建模後 放進CoppleliaSim裡進行物理模擬除錯 \n 反覆進行錯更改模型 \n \n \n \n \n', 'tags': '', 'url': 'stage1工作內容.html'}, {'title': 'stage1後記', 'text': '這次作業時間較短 只有4個禮拜 \n 花了較多時間再於設計及繪圖上 \n 以至於模擬除錯時間不足 導致沒有達到理想中的效果 \n \n 此次人數較少 單人作業量較高 \n 不過有利於對於磨練軟體熟練度及技術 \n 從中有學到了不少軟體使用上的技法 \n \n \n', 'tags': '', 'url': 'stage1後記.html'}, {'title': 'stage2', 'text': '\n 四人一組 以五個禮拜內設計產品 \n 組別網站 \n 產品題目 :四腳獸 \n \n 組員 \n 40823127 陳佑杰 \n 組員倉儲 \n 40823142 廖韋博 \n 組員倉儲 \n 40823144柯晉瑚 \n 組員倉儲 \n 40823148 韋誠昌 \n 組員倉儲 \n \n', 'tags': '', 'url': 'stage2.html'}, {'title': 'stage2工作內容', 'text': "負責連桿設計討論 行走模擬 \n 連桿設計討論 \n 此次連桿設計引用Jansen's linkage \n 第一版又自行設計連桿長度 但行走軌跡不如理想 \n 2.3版皆採用 Jansen's linkage連桿設計長度 \n \n 第二版採用6隻腳的設計 行走時較四隻腳平穩 \n 但中間腳的連桿會因軸穿越本體跟軸有干涉 後改成四足 \n \n 第三版改成四足設計 將原本曲柄交錯放置改成單邊放置 \n 且行走週期從三部分改成兩部分 再以交錯隻腳設為同動 \n 第三版實體圖▼ \n \n 2d軟體零件圖 ▼ \n \n \n 行走模擬 \n \n 此次模擬常遇到的問題有 \n 大量分件 \n dummy的串接 \n 實體碰撞的支撐性 \n 對於軟體需要一定的熟練度 非常考驗組裝邏輯和碰撞設定 \n \n \n", 'tags': '', 'url': 'stage2工作內容.html'}, {'title': 'stage2後記', 'text': '此次設計分為兩個作業向 連桿設計繪圖及行走模擬 \n 設計繪圖方面需要對連桿有一定知識 對於連桿長度及其考驗 \n 長度稍有不同 軌跡就會不同 \n 行走模擬考驗對軟體的熟練度以及組裝時的邏輯跟碰撞設定 \n 最常遇到的是大量分件的耐心 使用dummy使連桿串接 開啟實體碰撞時的支撐問題 \n \n 此次組員間合作良好 彼此都清楚各領域在做什麼 \n 不論在繪圖設計或模擬上的討論 大家都會提出想法及疑問 \n 人數適中 各組員進度比較好追蹤 \n 總而言之非常棒 \n', 'tags': '', 'url': 'stage2後記.html'}, {'title': 'stage3', 'text': '八人一組 在9個禮拜內設計產品 \n 組別網站 \n 產品題目 :四腳獸進階 \n 能自行行走 利用lua鍵盤控制兩軸轉速以達到轉彎 \n \n 組員 \n 張欽堯 40823114\xa0 repo \xa0 site \n 粘晁維 40823121\xa0 repo \xa0 site \n 陳佑杰 40823127\xa0 repo \xa0 site \n 林澤叡 40823135\xa0 repo \xa0 site \n 廖韋博 40823142\xa0 repo \xa0 site \n 柯晉瑚 40823144\xa0 repo \xa0 site \n 蕭宏翔 40823146\xa0 repo \xa0 site \n \n \n \n \n \n \n', 'tags': '', 'url': 'stage3.html'}, {'title': 'stage3工作內容', 'text': '\n', 'tags': '', 'url': 'stage3工作內容.html'}, {'title': 'stage3後記', 'text': '\n', 'tags': '', 'url': 'stage3後記.html'}, {'title': '個人作業', 'text': '\n \n', 'tags': '', 'url': '個人作業.html'}, {'title': 'SSH', 'text': '\n SSH 網路連線加密機制 \n SSH 指 Secure SHell, 是一種網路連線加密機制, 當我們在 Mac OS 或 Linux 操作系統中的 Terminal 或 XTerm 時, 可以利用 ssh 帳號@遠端主機 ip 或符號名稱, 就可以輸入認證密碼, 登入到遠端主機. \n 一般針對公開的 Github 倉儲, 任何人都可以直接透過 https 協定 clone 倉儲, 無需認證, 但是倉儲協同者若要從近端將改版資料送到 Github, 就必須通過認證, 假如採 https 協定, 則倉儲協同者在推送改版資料時, 必須提供帳號與密碼. \n 除了 https 協定, Github 也接受倉儲的協同者以 SSH 連線的方式, git clone private 倉儲, 或以 SSH 連線的方式將近端改版資料推送到遠端倉儲. \n SSH 的連線加密機制依賴 private key 與 public key 之間的配對, 當使用者建立 SSH key pair 時, private key 必須保護在近端, 而 public key 則必須送到進行認證的遠端伺服器中. \n \n ●SSH 操作步驟 \n \n 下載putty至近端data \n putty下載 \n \n 建立SSH Key \n \n 1.開啟編輯器輸入"sh" \n \n 2.輸入 ssh-keygen -t rsa -b 4096 -C "學號" 可得到ssh key \n ▼key的建立位置 \n ▼輸入y \n \n ▼enter至此即完成key建立 \n \n github建立shh key \n \n 3.找到路徑上的key \n \n 4.用SCITE把id_rsa.pub 開啟 複製裡面所有的文字 \n \n 5.到Github-->seeting-->SSH and GPG keys 按下"New SSH key" \n \n 6.Title 上寫上學號 Key 複製貼上剛剛的Key 再按下"Add SSH key" \n \n \n puttygen.exe \n \n 7.開啟puttygen.exe \n \n 8.按下"Load" \n \n ▼選取 選取id_rsa\xa0 \n \n ▼ 按下"save private key" 得到ppk 存到同一個路徑 \n \n ▼.ppk檔 \n \n putty.exe \n 9.開啟 putty.exe \n \n 10. 在"Saved Sessions" 輸入 "github.com" 在按下 "Save" \n \n 11.再到 "Auth" 找到"Private key file for authentication" 按下"browse"\xa0 \n \n ▼ 選取.ppk檔 \n \n 12.回到"session"\xa0 按下"github.com" 再按下 "Save" \n \n \n .git/config 與\xa0 start.bat 更改 \n 13.找到.git資料夾(*如果找不到這個資料夾記得在功能區--> 顯示-->將"隱藏的項目"勾選) \n \n 14.找到config 用SCITE開啟 \n \n 15.輸入 \n #url = https://github.com/40823148/cd2021.git\n    url = git@github.com:40823148/cd2021.git \n \n 16.找到\xa0start.bat\xa0 用SCITE開啟 \n \n 17.輸入 \n set GIT_HOME=%Disk%:\\portablegit\\bin\\\nset GIT_SSH=%Disk%:\\putty\\plink.exe \n \n 即完成SHH設置 \n end \n', 'tags': '', 'url': 'SSH.html'}, {'title': '機械手臂控制', 'text': '\n 利用 onshape 繪製手臂簡圖 手臂包含底座、手臂1、手臂2和夾頭 \n \n 組合圖▼ \n \n \n \n 匯出stl檔 丟入CoppeliaSim進行組合 \n 底座和手臂1連接一旋轉軸 \n 手臂1和手臂2連接一旋轉軸 \n 夾頭本身具有一旋轉軸及一上下移動軸 \n \n CoppeliaSim組合圖▼ \n \n \n 組合完成後分別以Lua程式、Lua鍵盤程式和python remote api進行模擬控制 \n 零件檔案', 'tags': '', 'url': '機械手臂控制.html'}, {'title': 'Lua程式控制', 'text': '\n 撰寫lua程式達到自動取放方塊 \n \n lua程式碼▼ \n function moving(x,y)\n    a=0.400\n    b=0.400\n    c=math.pow(math.pow(x,2)+math.pow(y,2),0.5)\n    s=(a+b+c)/2\n    area=math.pow((s*(s-a)*(s-b)*(s-c)),0.5)\n    h=area/(2*c)\n    deg1_base=math.atan(x/y)\n    if x<0 and y<0 then\n        deg1_base=deg1_base+math.pi\n    end\n    deg1_tri=math.asin(h/a)\n    deg1=deg1_base+deg1_tri\n    deg2=math.pi-(0.5*math.pi-deg1_tri)-math.acos(h/b)\n    deg3=deg2-deg1\n    sim.setJointTargetPosition(joint01,deg1)\n    sim.setJointTargetPosition(joint02,-deg2)\n    sim.setJointTargetPosition(joint03,deg3)\n    \nend\n\nfunction sysCall_threadmain()\n    joint01=sim.getObjectHandle(\'joint1\')\n    joint02=sim.getObjectHandle(\'joint2\')\n    joint03=sim.getObjectHandle(\'joint3\')\n    jointz=sim.getObjectHandle(\'jointz\')\n    sim.setJointTargetPosition(joint01,0)\n    sim.setJointTargetPosition(joint02,0)\n    sim.setJointTargetPosition(joint03,0)\n    sim.setJointTargetPosition(jointz,0)\n    sim.setIntegerSignal("pad_switch",1)\n    sim.setJointTargetPosition(jointz,-0.030)\n    sim.wait(2)\n    sim.setJointTargetPosition(jointz,0)\n     while sim.getSimulationState()~=sim.simulation_advancing_abouttostopre do\n        moving(0.2,0.7)\n        sim.wait(5)\n        sim.setIntegerSignal("pad_switch",0)\n        sim.wait(5)\n        sim.setIntegerSignal("pad_switch",1)\n        sim.setJointTargetPosition(jointz,-0.056)\n        sim.wait(5)\n        sim.setJointTargetPosition(jointz,0)\n        sim.wait(5)\n        moving(-0.3,-0.55)\n        sim.wait(5)\n        sim.setIntegerSignal("pad_switch",0)\n        sim.wait(5)\n        sim.setIntegerSignal("pad_switch",1)\n        sim.setJointTargetPosition(jointz,-0.06)\n        sim.wait(5)\n        sim.setJointTargetPosition(jointz,0)\n        sim.wait(5)\n        moving(0.1,0.55)\n        sim.wait(5)\n        sim.setIntegerSignal("pad_switch",0)\n        sim.wait(5)\n        sim.setIntegerSignal("pad_switch",1)\n        sim.setJointTargetPosition(jointz,-0.056)\n        sim.wait(5)\n        sim.setJointTargetPosition(jointz,0)\n        sim.wait(5)\n        moving(0,0.8)\n        sim.wait(5)\n        sim.setIntegerSignal("pad_switch",0)\n        sim.wait(5)\n        sim.setIntegerSignal("pad_switch",1)\n        sim.setJointTargetPosition(jointz,-0.056)\n        sim.wait(5)\n        sim.setJointTargetPosition(jointz,0)\n        sim.wait(5)\n    end\nend \n \n 成果影片▼ \n \n', 'tags': '', 'url': 'Lua程式控制.html'}, {'title': 'Lua鍵盤控制', 'text': '\n 撰寫Lua鍵盤控制程式 來達到使用鍵盤手動控制手臂位置及方塊取放 \n \n Lua鍵盤控制程式碼▼ \n function sysCall_init()\n    joint1=sim.getObjectHandle(\'joint1\')\n    joint2=sim.getObjectHandle(\'joint2\')\n    jointz=sim.getObjectHandle(\'jointZ\')\n    joint3=sim.getObjectHandle(\'joint3\')\n    sim.setJointTargetPosition(joint1,0)\n    sim.setJointTargetPosition(joint2,0)\n    sim.setJointTargetPosition(joint3,0)\n    sim.setJointTargetPosition(jointz,0)\n    deg1=0\n    deg2=0\n    deg3=0\nend\n\nfunction sysCall_actuation()\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==2009) then\n            deg1=deg1+10\n            deg3=deg2-deg1\n            sim.setJointTargetPosition(joint1,deg1*math.pi/180)\n            end\n            if (auxiliaryData[1]==2010) then\n            deg1=deg1-10\n            deg3=deg2-deg1\n            sim.setJointTargetPosition(joint1,deg1*math.pi/180)\n            end\n            if (auxiliaryData[1]==2007) then\n            deg2=deg2+10\n            deg3=deg1-deg2\n            sim.setJointTargetPosition(joint2,deg2*math.pi/180)\n            end\n            if (auxiliaryData[1]==2008) then\n            deg2=deg2-10\n            deg3=deg1-deg2\n            sim.setJointTargetPosition(joint2,deg2*math.pi/180)\n            end\n            if (auxiliaryData[1]==115) then\n                sim.setJointTargetPosition(jointz,-0.055)\n                sim.setIntegerSignal("pad_switch",1)\n            end\n            if(auxiliaryData[1]==119) then\n                sim.setJointTargetPosition(jointz,0)\n            end\n            if(auxiliaryData[1]==32) then\n                sim.setIntegerSignal("pad_switch",0)\n            end\n            sim.setJointTargetPosition(joint3,deg3*math.pi/180)\n        end\n    message,auxiliaryData=sim.getSimulatorMessage()\n    end\nend \n \n 成果影片▼ \n \n \n \n', 'tags': '', 'url': 'Lua鍵盤控制.html'}, {'title': 'python remote api', 'text': '\n 利用python remote api 在軟體外部控制方塊取放 \n \n python remote api程式碼▼ \n import sim as vrep\nimport math\nimport random\nimport time\nimport math\n\ndef moving(x,y):\n    a=0.400\n    b=0.400\n    c=math.pow(math.pow(x,2)+math.pow(y,2),0.5)\n    s=(a+b+c)/2\n    area=math.pow((s*(s-a)*(s-b)*(s-c)),0.5)\n    h=area/(2*c)\n    deg1_base=math.atan(x/y)\n    if x<0 and y<0 :\n        deg1_base=deg1_base+math.pi\n    deg1_tri=math.asin(h/a)\n    deg1=deg1_base+deg1_tri\n    deg2=math.pi-(0.5*math.pi-deg1_tri)-math.acos(h/b)\n    deg3=deg2-deg1\n    vrep.simxSetJointTargetPosition(clientID,joint01, deg1,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint02, -deg2,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint03, deg3,opmode)\n\n\nprint(\'start\')\n\nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19999, True, True, 5000, 5)\n \nif clientID!= -1:\n    print("Connected to remote API server")\n    \n    res=vrep.simxAddStatusbarMessage(\n        clientID,"123",\n        vrep.simx_opmode_oneshot)\n    if res not in (vrep.simx_return_ok,vrep.simx_return_novalue_flag):\n        print("could not add a message to the status bar.")\n        \n        \n    opmode=vrep.simx_opmode_oneshot_wait\n    STREAMING=vrep.simx_opmode_streaming\n    \n    vrep.simxStartSimulation(clientID,opmode)\n    ret,joint01=vrep.simxGetObjectHandle(clientID,"joint1",opmode)\n    ret,joint02=vrep.simxGetObjectHandle(clientID,"joint2",opmode)\n    ret,joint03=vrep.simxGetObjectHandle(clientID,"joint3",opmode)\n    ret,jointz=vrep.simxGetObjectHandle(clientID,"jointz",opmode)\n    \n    vrep.simxSetJointTargetPosition(clientID,joint01,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint02,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint03,0,opmode)\n    vrep.simxSetIntegerSignal(clientID,"pad_switch",1,opmode)\n    vrep.simxSetJointTargetPosition(clientID,jointz,-0.056,opmode)\n    time.sleep(1)\n    vrep.simxSetJointTargetPosition(clientID,jointz,0,opmode)\n    while True:\n        moving(0.2,0.7)\n        time.sleep(1)\n        vrep.simxSetIntegerSignal(clientID,"pad_switch",0,opmode)\n        time.sleep(1)\n        vrep.simxSetIntegerSignal(clientID,"pad_switch",1,opmode)\n        vrep.simxSetJointTargetPosition(clientID,jointz,-0.056,opmode)\n        time.sleep(1)\n        vrep.simxSetJointTargetPosition(clientID,jointz,0,opmode)\n        moving(-0.3,-0.55)\n        time.sleep(1)\n        vrep.simxSetIntegerSignal(clientID,"pad_switch",0,opmode)\n        time.sleep(1)\n        vrep.simxSetIntegerSignal(clientID,"pad_switch",1,opmode)\n        vrep.simxSetJointTargetPosition(clientID,jointz,-0.056,opmode)\n        time.sleep(1)\n        vrep.simxSetJointTargetPosition(clientID,jointz,0,opmode) \n \n 成果影片▼ \n \n \n \n \n', 'tags': '', 'url': 'python remote api.html'}, {'title': '亂數抽選', 'text': '\n \n', 'tags': '', 'url': '亂數抽選.html'}, {'title': 'stage1四驅車延伸', 'text': '新增兩種控制方式 並大幅簡化模擬實的模型 \n 完整實體圖▼ \n \n 簡化設計圖▼ \n \n coppliasim組合圖▼ \n', 'tags': '', 'url': 'stage1四驅車延伸.html'}, {'title': '鍵盤控制', 'text': "使用lua程式控制車子前進、後退和停止 \n lua程式碼▼ \n function sysCall_init() \n    left_front_handle= sim.getObjectHandle('s11')\n    left_back_handle= sim.getObjectHandle('s11')\n    right_back_handle= sim.getObjectHandle('s22')\n    right_front_handle= sim.getObjectHandle('s22')\n    MaxVel=27\n    leftvelocity=0\n    rightvelocity=0\n    dVel=2.7;\n    --sim.setJointTargetVelocity(left_front_handle,leftvelocity)\n    sim.setJointTargetVelocity(left_back_handle,leftvelocity)\n    sim.setJointTargetVelocity(right_back_handle,rightvelocity)\n    --sim.setJointTargetVelocity(right_front_handle,rightvelocity)\nend\n\nfunction sysCall_actuation() \n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==32) then\n                -- right key\n                leftvelocity=0\n                rightvelocity=0\n                sim.setJointForce(left_front_handle, 0)\n                sim.setJointForce(left_back_handle, 0)\n                sim.setJointForce(right_back_handle, 0)\n                sim.setJointForce(right_front_handle, 0)\n                break\n            else\n                --sim.setJointForce(left_front_handle, 10000)\n                sim.setJointForce(left_back_handle, 10000)\n                sim.setJointForce(right_back_handle, 10000)\n                --sim.setJointForce(right_front_handle, 10000)\n            end\n            if (auxiliaryData[1]==2008) then\n                -- up key\n                leftvelocity=(leftvelocity+rightvelocity)/2\n                rightvelocity=leftvelocity\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity+dVel\n            end\n            if (auxiliaryData[1]==2007) then\n                -- down key\n                leftvelocity=(leftvelocity+rightvelocity)/2\n                rightvelocity=leftvelocity\n                leftvelocity=leftvelocity-dVel\n                rightvelocity=rightvelocity-dVel\n            end\n            \n        end\n        message,auxiliaryData=sim.getSimulatorMessage()\n    end\n    \n    if leftvelocity>MaxVel then\n        leftvelocity=MaxVel\n    end\n    if leftvelocity<-MaxVel then\n        leftvelocity=-MaxVel\n    end\n    \n    if rightvelocity>MaxVel then\n                rightvelocity=MaxVel\n    end\n    if rightvelocity<-MaxVel then\n                rightvelocity=-MaxVel\n    end\n    \n    \n    sim.setJointTargetVelocity(left_back_handle,leftvelocity)\n    sim.setJointTargetVelocity(right_back_handle,rightvelocity)\n   \n    \nend  \n \n 成果影片▼ \n", 'tags': '', 'url': '鍵盤控制.html'}, {'title': 'python remote api 控制', 'text': '使用 python remote api 外部控制車子啟動 \n python程式碼▼ \n \n 成果影片▼ \n', 'tags': '', 'url': 'python remote api 控制.html'}, {'title': '影片', 'text': '\n \n \n', 'tags': '', 'url': '影片.html'}]};